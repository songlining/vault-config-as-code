# ğŸ—ï¸ Vault-as-Code Repository Architecture: Complete Design Overview

**Author:** Generated by Claude Code
**Date:** 2025-12-20
**Purpose:** Comprehensive architectural documentation for the Vault Configuration-as-Code repository

---

## ğŸ¯ Core Design Philosophy

This repository implements **HashiCorp Vault configuration as Infrastructure-as-Code** following these principles:

1. **Declarative YAML Configuration** - All config in version-controlled YAML files
2. **Convention-Based Routing** - File naming determines behavior (`human_*.yaml`, `application_*.yaml`)
3. **GitOps Workflow** - Git is the source of truth, Terraform applies changes
4. **Zero-Trust Identity** - SPIFFE-based cryptographic identity
5. **Multi-Modal Authentication** - Multiple auth methods â†’ single identity entity
6. **Least Privilege** - Fine-grained policies, separation of read/write access
7. **Automated Lifecycle** - Token rotation, certificate renewal, validation

---

## ğŸ“ Three-Layer Architecture

### **Layer 1: Configuration (YAML) ğŸ“**
```
Human-readable YAML files organized by resource type
â†“
7 directories: applications, identities, identity_groups, pkiroles,
               pki-auth-roles, awsauthroles, namespaces
â†“
JSON Schema validation for identities
```

### **Layer 2: Transformation (Terraform) ğŸ”„**
```
data.tf: YAML loading & parsing
â†“
local.* maps: Transform filename â†’ semantic keys
â†“
Filtered maps: Pre-compute auth-method-specific subsets
```

### **Layer 3: Resources (Vault) â˜ï¸**
```
Feature-specific .tf files consume local maps
â†“
for_each creates multiple resource instances
â†“
Modules encapsulate complex multi-resource patterns
â†“
Vault API calls create/update infrastructure
```

---

## ğŸ“‚ Directory Structure

```
vault-config-as-code/
â”œâ”€â”€ Core Terraform Files (Root Level)
â”‚   â”œâ”€â”€ main.tf                    # GitHub OAuth, JWT auth, PKI setup, transit engine
â”‚   â”œâ”€â”€ data.tf                    # YAML configuration loading and parsing
â”‚   â”œâ”€â”€ variables.tf               # Input variables (vault_url, environment)
â”‚   â”œâ”€â”€ versions.tf                # Provider versions
â”‚   â”œâ”€â”€ provider.tf                # Vault provider configuration
â”‚   â”œâ”€â”€ output.tf                  # Output values (PKI certs, tokens)
â”‚
â”œâ”€â”€ Feature-Specific Terraform Files
â”‚   â”œâ”€â”€ applications.tf            # KV module for applications
â”‚   â”œâ”€â”€ namespaces.tf              # Namespace module for tenants
â”‚   â”œâ”€â”€ identities.tf              # Identity entities and aliases
â”‚   â”œâ”€â”€ identity_groups.tf         # Identity group definitions
â”‚   â”œâ”€â”€ identity_token.tf          # OIDC token configuration
â”‚   â”œâ”€â”€ pkiroles.tf                # PKI role definitions
â”‚   â”œâ”€â”€ pki-auth.tf                # Certificate authentication backend
â”‚   â”œâ”€â”€ aws_auth_roles.tf          # AWS IAM authentication roles
â”‚   â”œâ”€â”€ trusted_orchestrator.tf    # Service account for automation
â”‚   â”œâ”€â”€ egp_policy.tf              # Sentinel policy enforcement
â”‚
â”œâ”€â”€ YAML Configuration Directories
â”‚   â”œâ”€â”€ applications/              # Application KV mount definitions
â”‚   â”‚   â”œâ”€â”€ example.yaml
â”‚   â”‚   â””â”€â”€ app-corebanking.yaml
â”‚   â”‚
â”‚   â”œâ”€â”€ namespaces/                # Multi-tenant namespace configs
â”‚   â”‚   â””â”€â”€ example.yaml
â”‚   â”‚
â”‚   â”œâ”€â”€ identities/                # Human and application identities
â”‚   â”‚   â”œâ”€â”€ schema_human.yaml      # JSON Schema for humans
â”‚   â”‚   â”œâ”€â”€ schema_application.yaml # JSON Schema for apps
â”‚   â”‚   â”œâ”€â”€ human_*.yaml           # Individual human identities
â”‚   â”‚   â”œâ”€â”€ application_*.yaml     # Individual application identities
â”‚   â”‚   â””â”€â”€ validate_identities.py # Python validation script
â”‚   â”‚
â”‚   â”œâ”€â”€ identity_groups/           # Group definitions with members
â”‚   â”‚   â””â”€â”€ identity_group_*.yaml
â”‚   â”‚
â”‚   â”œâ”€â”€ pkiroles/                  # PKI role configurations
â”‚   â”‚   â”œâ”€â”€ pkirole-machine-id.yaml
â”‚   â”‚   â”œâ”€â”€ pkirole-human-id.yaml
â”‚   â”‚   â””â”€â”€ pkirole-*.yaml
â”‚   â”‚
â”‚   â”œâ”€â”€ pki-auth-roles/            # Certificate auth role configs
â”‚   â”‚   â””â”€â”€ pki-auth-roles-*.yaml
â”‚   â”‚
â”‚   â”œâ”€â”€ awsauthroles/              # AWS IAM role configurations
â”‚   â”‚   â””â”€â”€ aws-ec2-*.yaml
â”‚   â”‚
â”‚   â””â”€â”€ usecases/                  # Usage documentation
â”‚       â””â”€â”€ vault-as-identity-provider.md
```

---

## ğŸ”‘ The Identity Model (Most Important!)

### **Two Parallel Systems:**

#### **1. PKI Auth Roles** (Authentication Rules)
```
pki-auth-roles/*.yaml
  â†“
vault_cert_auth_backend_role
  â†“
"Which certificates can authenticate?"
```

**Purpose:** Define **who can log in** via PKI certificates

**Example:**
```yaml
# pki-auth-roles/pki-auth-roles-appone.yaml
name: cicdpipeline
backend: cert
ttl: 1200
maxttl: 0
policies:
  - pki-self-renewal
  - super-user
allowed_machine_ids:
  - vault-client.machine-id.customer.demo
```

#### **2. Identity Entities** (Identity & Metadata)
```
identities/*.yaml
  â†“
vault_identity_entity + vault_identity_entity_alias
  â†“
"Who is this entity and what do they get?"
```

**Purpose:** Define **what they become** after authentication

**Example:**
```yaml
# identities/application_linux_host_vault-client.yaml
identity:
  name: "vault-client.machine-id.customer.demo"
  environment: "production"
  business_unit: "retail_banking"
authentication:
  pki: "vault-client.machine-id.customer.demo"
policies:
  identity_policies:
    - "application-identity-token-policies"
    - "super-user"
```

### **The Magic: They Work Together**

When a machine authenticates with a certificate:

1. âœ… **PKI auth role validates:** "Is this cert allowed?"
2. ğŸ”— **Entity alias resolves:** "Which identity entity does this map to?"
3. ğŸ« **Token issued with:** Auth role policies + Entity policies + Entity metadata

**Result:** Single identity, multiple authentication methods!

```
vault_identity_entity["Yulei Liu"]
  â”œâ”€ Alias: github â†’ "ausmartway"
  â”œâ”€ Alias: pki â†’ "yulei.human-id.customer.demo"
  â””â”€ Both login methods â†’ same identity â†’ same permissions!
```

---

## ğŸ”„ Complete Data Flow: YAML to Vault

### **Step-by-Step Example: Adding a New Human**

#### **Step 1: YAML File Created** ğŸ“
```yaml
# identities/human_alice.yaml
$schema: "./schema_human.yaml"

metadata:
  version: "1.0.0"
  created_date: "2025-12-20"
  description: "Human Identity for Alice Smith"

identity:
  name: "Alice Smith"
  email: "alice@hashicorp.com"
  role: "engineer"
  team: "platform"

authentication:
  github: "alice-gh"
  pki: "alice.human-id.customer.demo"

policies:
  identity_policies:
    - "human-identity-token-policies"
```

#### **Step 2: File Discovery** ğŸ”
**File:** `data.tf:5-17`

```hcl
data "local_file" "config_files" {
  for_each = toset([
    for f in fileset(path.module, "{...,identities,...}/*.yaml") : f
    if f != "identities/example.yaml"
  ])
  filename = "${path.module}/${each.value}"
}
```

**Result:**
```hcl
data.local_file.config_files["identities/human_alice.yaml"] = {
  content = "identity:\n  name: Alice Smith\n..."
}
```

#### **Step 3: YAML Parsing** ğŸ”„
**File:** `data.tf:21-24`

```hcl
all_configs = {
  for path, file in data.local_file.config_files :
  path => try(yamldecode(file.content), null)
}
```

**Result:**
```hcl
local.all_configs["identities/human_alice.yaml"] = {
  identity = {
    name  = "Alice Smith"
    email = "alice@hashicorp.com"
    role  = "engineer"
    team  = "platform"
  }
  authentication = {
    github = "alice-gh"
    pki    = "alice.human-id.customer.demo"
  }
  policies = {
    identity_policies = ["human-identity-token-policies"]
  }
}
```

#### **Step 4: Grouping by Type** ğŸ“‚
**File:** `data.tf:40`

```hcl
configs_by_type = {
  identities = {
    for path, config in local.valid_configs :
    trimsuffix(basename(path), ".yaml") => config
    if startswith(path, "identities/")
  }
}
```

**Result:**
```hcl
local.configs_by_type.identities = {
  "human_alice" = {  # filename becomes key
    identity = {...}
    authentication = {...}
  }
}
```

#### **Step 5: Transform to Final Map** ğŸ—ºï¸
**File:** `data.tf:82-86`

```hcl
human_identities_map = {
  for filename, config in local.configs_by_type.identities :
  config.identity.name => config  # Use 'identity.name' field as key
  if startswith(filename, "human_")
}
```

**Result:**
```hcl
local.human_identities_map = {
  "Alice Smith" = {  # identity.name field becomes the key!
    identity = {
      name  = "Alice Smith"
      email = "alice@hashicorp.com"
      role  = "engineer"
      team  = "platform"
    }
    authentication = {
      github = "alice-gh"
      pki    = "alice.human-id.customer.demo"
    }
    policies = {
      identity_policies = ["human-identity-token-policies"]
    }
  }
}
```

#### **Step 6: Authentication Method Filtering** ğŸ”
**File:** `data.tf:96-104`

```hcl
human_with_github = {
  for k, v in local.human_identities_map :
  k => v if try(v.authentication.github, null) != null && v.authentication.github != ""
}

human_with_pki = {
  for k, v in local.human_identities_map :
  k => v if try(v.authentication.pki, null) != null && v.authentication.pki != ""
}
```

**Result:** Alice has BOTH, so appears in both maps:
```hcl
local.human_with_github["Alice Smith"] = {...}
local.human_with_pki["Alice Smith"]    = {...}
```

#### **Step 7: Create Identity Entity** ğŸ‘¤
**File:** `identities.tf:2-11`

```hcl
resource "vault_identity_entity" "human" {
  for_each = local.human_identities_map
  name     = each.key  # "Alice Smith"
  policies = concat(
    [for i in each.value.policies.identity_policies : i],
    ["human-identity-token-policies"]
  )
  metadata = {
    role      = each.value.identity.role       # "engineer"
    team      = each.value.identity.team       # "platform"
    email     = each.value.identity.email      # "alice@hashicorp.com"
    spiffe_id = "spiffe://vault/human/engineer/platform/Alice Smith"
  }
}
```

**Creates:**
```
vault_identity_entity.human["Alice Smith"]
```

#### **Step 8: Create GitHub Alias** ğŸ”—
**File:** `identities.tf:14-19`

```hcl
resource "vault_identity_entity_alias" "github" {
  for_each       = local.human_with_github  # Alice is in this!
  mount_accessor = vault_github_auth_backend.hashicorp.accessor
  canonical_id   = vault_identity_entity.human[each.key].id
  name           = each.value.authentication.github  # "alice-gh"
}
```

**Creates:**
```
vault_identity_entity_alias.github["Alice Smith"]
```

#### **Step 9: Create PKI Alias** ğŸ”
**File:** `identities.tf:22-27`

```hcl
resource "vault_identity_entity_alias" "pki" {
  for_each       = local.human_with_pki  # Alice is in this too!
  mount_accessor = vault_auth_backend.cert.accessor
  canonical_id   = vault_identity_entity.human[each.key].id  # Same entity!
  name           = each.value.authentication.pki  # "alice.human-id.customer.demo"
}
```

**Creates:**
```
vault_identity_entity_alias.pki["Alice Smith"]
```

#### **Step 10: Final Vault State** ğŸ¯

After `terraform apply`, Vault has:

```
Identity Entity: "Alice Smith"
â”œâ”€â”€ ID: entity-abc123
â”œâ”€â”€ Policies: ["human-identity-token-policies"]
â”œâ”€â”€ Metadata:
â”‚   â”œâ”€â”€ role: "engineer"
â”‚   â”œâ”€â”€ team: "platform"
â”‚   â”œâ”€â”€ email: "alice@hashicorp.com"
â”‚   â””â”€â”€ spiffe_id: "spiffe://vault/human/engineer/platform/Alice Smith"
â””â”€â”€ Aliases:
    â”œâ”€â”€ GitHub: "alice-gh" â†’ auth/github/
    â””â”€â”€ PKI: "alice.human-id.customer.demo" â†’ auth/cert/
```

#### **Step 11: Alice Can Now Login!** ğŸ‰

**Method 1: GitHub OAuth**
```bash
vault login -method=github token=ghp_xxxxx
```

1. Vault checks: "Is alice-gh a HashiCorp org member?"
2. Vault looks up alias with `name = "alice-gh"` on GitHub auth mount
3. Alias points to entity ID `entity-abc123`
4. Vault loads entity "Alice Smith" with all metadata & policies
5. Token issued with policies and metadata

**Method 2: PKI Certificate**
```bash
vault login -method=cert \
  -client-cert=alice.crt \
  -client-key=alice.key
```

1. Vault validates certificate against CA
2. Vault extracts CN: `alice.human-id.customer.demo`
3. Vault looks up alias with `name = "alice.human-id.customer.demo"` on cert mount
4. Alias points to **same** entity ID `entity-abc123`
5. Same "Alice Smith" entity loaded
6. Same policies & metadata!

**Both methods â†’ Same identity â†’ Same permissions!**

---

## ğŸ§© Key Components Deep Dive

### **1. data.tf - The Configuration Hub**

**Purpose:** Central YAML loading and transformation system

**What it does:**
- **Discovers** all YAML files via `fileset()`
- **Parses** YAML into Terraform data structures
- **Groups** by type (applications, identities, etc.)
- **Transforms** filename keys â†’ semantic keys (e.g., `config.name`)
- **Filters** by auth method (e.g., `human_with_github`)
- **Validates** structure via `try()` error handling

**Key Locals:**

| Local Variable | Key Field | Purpose |
|----------------|-----------|---------|
| `applications_map` | `config.appid` | Application KV mounts |
| `aws_auth_roles_map` | `config.role` | AWS IAM roles |
| `namespaces_map` | `config.name` | Vault namespaces |
| `pki_auth_roles_map` | `config.name` | PKI auth roles |
| `identity_groups_map` | `config.name` | Identity groups |
| `pki_roles_map` | `config.name` | PKI certificate roles |
| `human_identities_map` | `config.identity.name` | Human identities |
| `application_identities_map` | `config.identity.name` | App identities |
| `human_with_github` | Filtered | Humans with GitHub auth |
| `human_with_pki` | Filtered | Humans with PKI auth |
| `app_with_github_repo` | Filtered | Apps with GitHub repo auth |
| `app_with_pki` | Filtered | Apps with PKI auth |
| `app_with_tfc_workspace` | Filtered | Apps with TFC auth |

### **2. identities.tf - Identity Management**

**Creates:**
- **Identity entities** (humans + applications)
- **Entity aliases** linking auth methods to entities

**Resources:**

```hcl
# Human Identities
vault_identity_entity.human           # The identity entity
vault_identity_entity_alias.github    # GitHub username â†’ entity
vault_identity_entity_alias.pki       # PKI certificate CN â†’ entity

# Application Identities
vault_identity_entity.application           # The identity entity
vault_identity_entity_alias.app_pki         # PKI certificate CN â†’ entity
vault_identity_entity_alias.app_github_repo # GitHub repo â†’ entity
vault_identity_entity_alias.app_tfc_workspace # TFC workspace â†’ entity
```

**Supports:**
- Multiple auth methods per entity
- Rich metadata (role, team, SPIFFE ID)
- Policy attachment at entity level

### **3. identity_token.tf - OIDC Provider**

**Purpose:** Vault acts as an OIDC identity provider

**What it creates:**

```hcl
# Global OIDC configuration
vault_identity_oidc (issuer: vault_url)

# Human Identity Tokens
vault_identity_oidc_key.human_identity (RS256)
vault_identity_oidc_role.human_identity
  â”œâ”€ TTL: 8 hours
  â”œâ”€ Client ID: spiffe://kgateway
  â””â”€ Token includes:
      â”œâ”€ SPIFFE ID: spiffe://vault/human/{role}/{team}/{name}
      â”œâ”€ Groups
      â””â”€ User info: name, email, role, team

vault_policy.human-identity-token-policies
  â””â”€ Access to: identity/oidc/token/human_identity

# Application Identity Tokens
vault_identity_oidc_key.application_identity (RS256)
vault_identity_oidc_role.application_identity
  â”œâ”€ TTL: 30 minutes
  â”œâ”€ Client ID: spiffe://kgateway
  â””â”€ Token includes:
      â”œâ”€ SPIFFE ID: spiffe://vault/application/{env}/{unit}/{name}
      â”œâ”€ Groups
      â””â”€ App info: business_unit, environment

vault_policy.application-identity-token-policies
  â””â”€ Access to: identity/oidc/token/application_identity

# OIDC Provider
vault_identity_oidc_provider.default
  â”œâ”€ Issuer host: nginx:443
  â””â”€ Allowed client IDs: [human_identity, application_identity]
```

**Token Usage:**
```bash
# Human generates token
vault read identity/oidc/token/human_identity

# Application generates token
vault read identity/oidc/token/application_identity
```

### **4. main.tf - Core Infrastructure**

**Authentication Backends:**
- **GitHub OAuth** (`vault_github_auth_backend`)
  - Organization: hashicorp
  - Token TTL: 8 hours
  - Token Max TTL: 7 days

- **GitHub Actions JWT** (`vault_jwt_auth_backend`)
  - OIDC discovery URL: token.actions.githubusercontent.com
  - Bound audience: base64("Yulie's Vault")
  - User claim: repository

- **Terraform Cloud JWT** (`vault_jwt_auth_backend`)
  - OIDC discovery URL: app.terraform.io
  - Bound audience: base64("Yulie's Vault")
  - User claim: terraform_full_workspace

- **AWS IAM** (`vault_auth_backend` type: aws)
- **AppRole** (`vault_auth_backend` type: approle)

**PKI Infrastructure:**
```hcl
# Root CA (10-year self-signed)
vault_mount.pki_root
vault_pki_secret_backend_root_cert.root
  â”œâ”€ Common Name: "anz.hashicorp.demo Root Authority"
  â”œâ”€ TTL: 87600 hours (10 years)
  â””â”€ Organization: HashiCorp

# Intermediate CA (2-3 year chain)
vault_mount.pki_intermediate
vault_pki_secret_backend_intermediate_cert_request.intermediate
vault_pki_secret_backend_root_sign_intermediate.intermediate
  â”œâ”€ Common Name: "anz.hashicorp.demo Intermediate Authority"
  â”œâ”€ TTL: 26280 hours (~3 years)
  â””â”€ Usage: digital_signature, key_encipherment, key_cert_sign
```

**Secrets Engines:**
- **KV v2** (`vault_mount` type: kv-v2)
  - Path: `secret/`
  - Super-user has read/write access

- **Transit** (`vault_mount` type: transit)
  - Path: `EaaS/`
  - Key: `hashi-encryption-key`
  - Encryption-as-a-Service

- **AWS** (`vault_aws_secret_backend`)
  - Roles: iam_manager, s3_manager, cicd
  - Dynamic AWS credential generation

- **SSH** (`vault_mount` type: ssh)
  - Path: `ssh-client-signer/`
  - CA-based SSH certificate signing

**Service Accounts:**
```hcl
# Superuser Token (Terraform Cloud)
vault_token.superuser
  â”œâ”€ Policies: ["super-user"]
  â”œâ”€ TTL: 768 hours (32 days)
  â”œâ”€ Renewable: true
  â”œâ”€ Auto-rotation: every 30 days
  â””â”€ Lifecycle: create_before_destroy

time_rotating.rotate
  â””â”€ Rotation period: 30 days
```

### **5. Modules - Encapsulated Patterns**

#### **Applications Module**
**Source:** `ausmartway/kv-for-application/vault` v0.4.1

**Input:**
```yaml
# applications/app-corebanking.yaml
appid: Corebanking
name: Corebanking
contact: yulei@hashicorp.com
enable_approle: true
environments:
  - production
  - dev
```

**Creates:**
```
Per application, per environment:
â”œâ”€ KV v2 mount: secret/{appid}/{env}/
â”œâ”€ Policy: {appid}-{env}-secret-provider (read/write)
â”œâ”€ Policy: {appid}-{env}-secret-consumer (read-only)
â””â”€ AppRole credentials (if enabled)

Example for Corebanking:
â”œâ”€ secret/Corebanking/production/
â”‚  â”œâ”€ Corebanking-production-secret-provider policy
â”‚  â””â”€ Corebanking-production-secret-consumer policy
â””â”€ secret/Corebanking/dev/
   â”œâ”€ Corebanking-dev-secret-provider policy
   â””â”€ Corebanking-dev-secret-consumer policy
```

#### **Namespace Module**
**Source:** `ausmartway/namespace/vault` v0.0.3

**Input:**
```yaml
# namespaces/example_namespace.yaml
name: example_namespace
owner: yulei@hashicorp.com
```

**Creates:**
```
vault_namespace "{name}"
â”œâ”€ Isolated namespace
â”œâ”€ Admin token for delegation
â””â”€ Complete resource isolation
```

---

## ğŸ” Authentication Strategies

### **Authentication Matrix**

| User Type | Primary Auth | Secondary Auth | Token TTL | Use Case |
|-----------|-------------|----------------|-----------|----------|
| **Humans** | GitHub OAuth | PKI Certificate | 8 hours | Interactive access |
| **CI/CD Pipelines** | GitHub Actions JWT | - | 1 hour | Automated workflows |
| **Terraform Cloud** | TFC JWT | - | 1 hour | Infrastructure automation |
| **EC2 Instances** | AWS IAM | PKI Certificate | 1 hour | Cloud workloads |
| **Applications** | PKI Certificate | AWS IAM / AppRole | 20 min - 1 hour | Services |
| **Service Accounts** | Long-lived Token | - | 32 days (rotating) | Terraform Cloud mgmt |

### **Authentication Flow Comparison**

#### **Human Authentication (GitHub OAuth)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   User      â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ 1. vault login -method=github
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ GitHub OAuth        â”‚
â”‚ (HashiCorp org)     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ 2. Verify membership
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Entity Alias        â”‚
â”‚ github â†’ "alice-gh" â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ 3. Resolve to entity
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Identity Entity     â”‚
â”‚ "Alice Smith"       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Policies            â”‚
â”‚ Metadata            â”‚
â”‚ Groups              â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ 4. Issue token
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Vault Token         â”‚
â”‚ TTL: 8 hours        â”‚
â”‚ + All policies      â”‚
â”‚ + Entity metadata   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### **Application Authentication (PKI Certificate)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Application â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ 1. Present certificate
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PKI Auth Role       â”‚
â”‚ "cicdpipeline"      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Validates:          â”‚
â”‚ - Certificate valid â”‚
â”‚ - CN allowed        â”‚
â”‚ - Issued by CA      â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ 2. Auth successful
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Entity Alias        â”‚
â”‚ pki â†’ "app.mach..." â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ 3. Resolve to entity
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Identity Entity     â”‚
â”‚ "App Backend"       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Auth role policies  â”‚
â”‚ + Entity policies   â”‚
â”‚ + Metadata          â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ 4. Issue token
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Vault Token         â”‚
â”‚ TTL: 20-60 min      â”‚
â”‚ + Merged policies   â”‚
â”‚ + SPIFFE ID         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ­ The "Why Two Files" Pattern Explained

### **PKI Auth Role vs Application Identity**

This is one of the most important architectural decisions in this repository.

#### **Comparison Table:**

| Aspect | PKI Auth Role | Application Identity |
|--------|---------------|---------------------|
| **File Location** | `pki-auth-roles/*.yaml` | `identities/application_*.yaml` |
| **Purpose** | Authentication rules | Identity definition |
| **Terraform Resource** | `vault_cert_auth_backend_role` | `vault_identity_entity` + alias |
| **Answers** | "Can this cert authenticate?" | "Who is this entity?" |
| **Policies** | Auth-time policies | Identity-level policies |
| **Metadata** | None | Rich metadata (env, business unit, SPIFFE) |
| **Scope** | One role can match many certs | One identity, many auth methods |
| **File in** | `pki-auth.tf` | `identities.tf` |

#### **Concrete Example:**

**PKI Auth Role File:**
```yaml
# pki-auth-roles/pki-auth-roles-appone.yaml
name: cicdpipeline
backend: cert
ttl: 1200
maxttl: 0
contact: yulei@hashicorp.com
policies:
  - pki-self-renewal
  - super-user
  - ad-consumer
  - server-pki
  - client-pki
allowed_machine_ids:
  - vault-client.machine-id.customer.demo
```

**Application Identity File:**
```yaml
# identities/application_linux_host_vault-client.yaml
identity:
  name: "vault-client.machine-id.customer.demo"
  contact: "yulei@hashicorp.com"
  environment: "production"
  business_unit: "retail_banking"
authentication:
  pki: "vault-client.machine-id.customer.demo"
policies:
  identity_policies:
    - "application-identity-token-policies"
    - "super-user"
```

#### **How They Work Together:**

```
Machine "vault-client.machine-id.customer.demo" authenticates:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 1: PKI Auth Role validates certificate                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ pki-auth-roles-appone.yaml                                  â”‚
â”‚   â†“                                                         â”‚
â”‚ vault_cert_auth_backend_role["cicdpipeline"]                â”‚
â”‚   â†“                                                         â”‚
â”‚ Checks:                                                     â”‚
â”‚ - Is CN "vault-client.machine-id.customer.demo"?  âœ“         â”‚
â”‚ - Is cert signed by intermediate CA?  âœ“                     â”‚
â”‚ - Is cert valid (not expired)?  âœ“                           â”‚
â”‚   â†“                                                         â”‚
â”‚ Grants policies:                                            â”‚
â”‚ - pki-self-renewal                                          â”‚
â”‚ - super-user                                                â”‚
â”‚ - ad-consumer                                               â”‚
â”‚ - server-pki                                                â”‚
â”‚ - client-pki                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 2: Identity Entity provides context                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ application_linux_host_vault-client.yaml                    â”‚
â”‚   â†“                                                         â”‚
â”‚ vault_identity_entity["vault-client.machine-id..."]         â”‚
â”‚   â†“                                                         â”‚
â”‚ Adds policies:                                              â”‚
â”‚ - application-identity-token-policies                       â”‚
â”‚ - super-user                                                â”‚
â”‚   â†“                                                         â”‚
â”‚ Adds metadata:                                              â”‚
â”‚ - environment: production                                   â”‚
â”‚ - business_unit: retail_banking                             â”‚
â”‚ - spiffe_id: spiffe://vault/application/production/...      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Final Token                                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Policies (merged, duplicates OK):                           â”‚
â”‚ - pki-self-renewal                                          â”‚
â”‚ - super-user (from both!)                                   â”‚
â”‚ - ad-consumer                                               â”‚
â”‚ - server-pki                                                â”‚
â”‚ - client-pki                                                â”‚
â”‚ - application-identity-token-policies                       â”‚
â”‚                                                             â”‚
â”‚ Metadata (from entity):                                     â”‚
â”‚ - environment: production                                   â”‚
â”‚ - business_unit: retail_banking                             â”‚
â”‚ - spiffe_id: spiffe://vault/application/production/...      â”‚
â”‚                                                             â”‚
â”‚ Capabilities:                                               â”‚
â”‚ - Can renew its own certificate (pki-self-renewal)          â”‚
â”‚ - Can generate OIDC tokens (application-identity-token...)  â”‚
â”‚ - Can issue server/client certificates                      â”‚
â”‚ - Has superuser privileges                                  â”‚
â”‚ - Can access AD consumer API                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### **Why Separate Files?**

1. **Separation of Concerns:**
   - **Auth role:** "Which certificates can authenticate?"
   - **Identity:** "Who are they and what metadata do they have?"

2. **Flexibility:**
   - One application identity can have multiple auth methods:
     - PKI certificate
     - AWS IAM role
     - GitHub repo OIDC
     - Terraform Cloud workspace
   - Each auth method has its own config file
   - All link to the same identity entity

3. **Reusability:**
   - One PKI auth role can allow multiple certificates
   - Multiple identities can use the same auth role

4. **Different Lifecycles:**
   - Auth roles change when security requirements change
   - Identities change when organizational structure changes

---

## ğŸš€ Workflow: Adding New Resources

### **Scenario 1: Add a New Human User**

#### **1. Create YAML File**
```yaml
# identities/human_bob.yaml
$schema: "./schema_human.yaml"

metadata:
  version: "1.0.0"
  created_date: "2025-12-20"
  description: "Human Identity for Bob Johnson"

identity:
  name: "Bob Johnson"
  email: "bob@hashicorp.com"
  role: "engineer"
  team: "security"

authentication:
  pki: "bob.human-id.customer.demo"
  github: "bob-gh"

policies:
  identity_policies:
    - "human-identity-token-policies"
```

#### **2. Validate**
```bash
cd identities
python3 validate_identities.py
```

Expected output:
```
âœ“ All identity files are valid!
```

#### **3. Plan Changes**
```bash
terraform plan
```

Expected resources:
```
Terraform will perform the following actions:

  # vault_identity_entity.human["Bob Johnson"] will be created
  + resource "vault_identity_entity" "human" {
      + name     = "Bob Johnson"
      + policies = ["human-identity-token-policies"]
      + metadata = {
          + email     = "bob@hashicorp.com"
          + role      = "engineer"
          + team      = "security"
          + spiffe_id = "spiffe://vault/human/engineer/security/Bob Johnson"
        }
    }

  # vault_identity_entity_alias.github["Bob Johnson"] will be created
  + resource "vault_identity_entity_alias" "github" {
      + name           = "bob-gh"
      + canonical_id   = (known after apply)
      + mount_accessor = "auth_github_..."
    }

  # vault_identity_entity_alias.pki["Bob Johnson"] will be created
  + resource "vault_identity_entity_alias" "pki" {
      + name           = "bob.human-id.customer.demo"
      + canonical_id   = (known after apply)
      + mount_accessor = "auth_cert_..."
    }

Plan: 3 to add, 0 to change, 0 to destroy.
```

#### **4. Apply**
```bash
terraform apply
```

#### **5. Bob Can Now Login!**
```bash
# Via GitHub
vault login -method=github token=ghp_xxxxx

# Via PKI certificate
vault login -method=cert \
  -client-cert=bob.crt \
  -client-key=bob.key
```

---

### **Scenario 2: Add a New Application**

This requires **three YAML files** (Application KV, Identity, Auth Role).

#### **1. Create Application KV Config**
```yaml
# applications/app-payments.yaml
appid: Payments
name: Payments
contact: ops@hashicorp.com
enable_approle: true
environments:
  - production
  - staging
  - dev
```

**Creates:**
- KV mounts: `secret/Payments/production/`, `secret/Payments/staging/`, `secret/Payments/dev/`
- Policies for each environment (provider + consumer)
- AppRole credentials

#### **2. Create Application Identity**
```yaml
# identities/application_payments_backend.yaml
$schema: "./schema_application.yaml"

metadata:
  version: "1.0.0"
  created_date: "2025-12-20"
  description: "Payments Backend Service Identity"

identity:
  name: "payments-backend.machine-id.customer.demo"
  contact: "ops@hashicorp.com"
  environment: "production"
  business_unit: "fintech"

authentication:
  aws_auth_role: ""
  pki: "payments-backend.machine-id.customer.demo"
  github_repo: "myorg/payments-backend"
  tfc_workspace: ""

policies:
  identity_policies:
    - "application-identity-token-policies"
    - "Payments-production-secret-consumer"
```

**Creates:**
- Identity entity with metadata
- PKI alias (if pki field set)
- GitHub repo alias (if github_repo field set)

#### **3. Create PKI Auth Role**
```yaml
# pki-auth-roles/pki-auth-roles-payments.yaml
name: payments
backend: cert
ttl: 3600
maxttl: 7200
contact: ops@hashicorp.com
policies:
  - pki-self-renewal
  - Payments-production-secret-consumer
allowed_machine_ids:
  - payments-backend.machine-id.customer.demo
  - payments-worker.machine-id.customer.demo
```

**Creates:**
- PKI auth role that validates certificates
- Grants policies on successful authentication

#### **4. Apply**
```bash
terraform plan
terraform apply
```

#### **5. Application Can Now Authenticate!**

**Via PKI Certificate:**
```bash
vault login -method=cert \
  -client-cert=payments-backend.crt \
  -client-key=payments-backend.key
```

**Via GitHub Actions (in CI/CD):**
```yaml
# .github/workflows/deploy.yml
jobs:
  deploy:
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Get Vault Token
        uses: hashicorp/vault-action@v2
        with:
          url: https://vault.example.com
          method: jwt
          role: default
          jwtGithubAudience: "base64-encoded-audience"
```

---

### **Scenario 3: Add User to Identity Group**

#### **1. Edit Group File**
```yaml
# identity_groups/identity_group_platform.yaml
name: Platform Engineering
contact: platform@hashicorp.com

human_identities:
  - Yulei Liu
  - Simon Lynch
  - Bob Johnson      # â† Add Bob here

application_identities: []

sub_groups:
  - Platform Tools
  - Platform Infrastructure

identity_group_policies:
  - platform-admin
```

#### **2. Apply**
```bash
terraform plan
terraform apply
```

**Result:** Bob now inherits all group policies!

---

## ğŸ›¡ï¸ Security Features

### **Built-in Security Controls:**

| Feature | Implementation | Benefit |
|---------|----------------|---------|
| **Least Privilege** | Separate read/write policies per app | Minimize blast radius |
| **Certificate-Based Identity** | PKI for machine authentication | Zero-trust, cryptographic verification |
| **Short-lived Credentials** | Tokens expire (8h humans, 30m apps) | Limit exposure window |
| **Auto-Rotation** | Service account tokens rotate every 30 days | Fresh credentials, reduced risk |
| **Multi-Factor** | Multiple auth methods for redundancy | Availability + security |
| **Audit Trail** | All changes in Git history | Full accountability |
| **Pre-Apply Validation** | Pre-commit hooks, JSON Schema | Catch errors early |
| **Sentinel Policies** | EGP enforces cert issuance rules | Policy-as-code enforcement |
| **Namespace Isolation** | Multi-tenancy support | Complete resource separation |
| **SPIFFE Identity** | Cryptographic workload identity | Service mesh ready |

### **Validation Pipeline:**

```
Developer edits YAML
  â†“
1. JSON Schema validation (identities/validate_identities.py)
  â†“
2. Pre-commit hooks (.pre-commit-config.yaml)
  â”œâ”€ terraform_fmt (formatting)
  â”œâ”€ terraform_validate (syntax)
  â”œâ”€ terraform_tflint (linting)
  â””â”€ terraform_trivy (security scanning)
  â†“
3. Terraform plan (review changes)
  â†“
4. Manual review (if needed)
  â†“
5. Terraform apply (deploy to Vault)
  â†“
6. Vault enforces policies (Sentinel EGP)
```

### **Sentinel Policy Example:**

**File:** `egp_policy.tf`

```hcl
# Ensures entities can only request certificates for their own SPIFFE ID
resource "vault_egp_policy" "pki_issuance" {
  name              = "pki-issuance-control"
  enforcement_level = "hard-mandatory"

  policy = <<EOT
import "strings"

# Get the entity metadata
entity_metadata = request.entity.metadata

# Get the requested common_name
requested_cn = request.data.common_name

# Ensure the requested CN matches the entity's expected pattern
main = rule {
  strings.has_prefix(requested_cn, entity_metadata.name)
}
EOT

  paths = ["pki_intermediate/issue/*"]
}
```

**What it does:**
- Blocks applications from requesting certificates for other applications
- Enforces that `common_name` matches entity metadata
- Hard-mandatory = cannot be overridden

---

## ğŸ’¡ Design Patterns & Best Practices

### **1. Convention Over Configuration**

**File Naming Drives Behavior:**
```
identities/human_alice.yaml     â†’ Human identity
identities/application_api.yaml â†’ Application identity
```

**Why it works:**
- Less boilerplate
- Self-documenting
- Enforces consistency

### **2. Semantic Keys for Stability**

**Bad (using filename as key):**
```hcl
vault_identity_entity.human["human_alice"] # Filename
```

Rename file â†’ Terraform destroys and recreates resource! ğŸ’¥

**Good (using semantic field as key):**
```hcl
vault_identity_entity.human["Alice Smith"] # identity.name
```

Rename file â†’ No Terraform changes! âœ…

### **3. Filtered Maps for Conditional Resources**

**Problem:** Not all identities use all auth methods

**Solution:** Pre-filter in `data.tf`
```hcl
human_with_github = {
  for k, v in local.human_identities_map :
  k => v if try(v.authentication.github, null) != null
}
```

**Benefit:** Only create aliases for configured auth methods

### **4. Modules for Multi-Resource Patterns**

**Without Module:**
```hcl
# Would need to manually create:
resource "vault_mount" "app_kv" { ... }
resource "vault_policy" "app_reader" { ... }
resource "vault_policy" "app_writer" { ... }
resource "vault_approle_auth_backend_role" "app_role" { ... }
# ... repeated for every app/env combination
```

**With Module:**
```hcl
module "applications" {
  source   = "ausmartway/kv-for-application/vault"
  for_each = local.applications_map
  # ... simple config
}
# Module creates all resources automatically
```

### **5. Create Before Destroy for High Availability**

**Service Account Token Rotation:**
```hcl
resource "vault_token" "superuser" {
  # ...
  lifecycle {
    create_before_destroy = true
    replace_triggered_by  = [time_static.rotate]
  }
}
```

**Ensures:** New token created before old one destroyed = zero downtime

### **6. Error Handling with try()**

**Graceful YAML Parsing:**
```hcl
all_configs = {
  for path, file in data.local_file.config_files :
  path => try(yamldecode(file.content), null)
}

valid_configs = {
  for path, config in local.all_configs :
  path => config if config != null
}
```

**Benefits:**
- Invalid YAML doesn't crash Terraform
- Can identify which files failed
- Fail gracefully

### **7. SPIFFE for Cryptographic Identity**

**Format:**
```
spiffe://vault/{type}/{role}/{team}/{name}
spiffe://vault/human/engineer/platform/Alice Smith
spiffe://vault/application/production/fintech/payments-backend
```

**Why:**
- Globally unique
- Hierarchical structure
- Service mesh compatible
- Supports federation

---

## ğŸ“Š Architecture Diagrams

### **High-Level Component Diagram**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Git Repository                          â”‚
â”‚                  (Source of Truth)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚ â”‚applications/â”‚ â”‚ identities/ â”‚ â”‚pki-auth-   â”‚            â”‚
â”‚ â”‚  *.yaml     â”‚ â”‚  *.yaml     â”‚ â”‚  roles/     â”‚   + 4 more â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â”‚ terraform apply
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Terraform                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ data.tf (Configuration Loading)                    â”‚    â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚  â”‚ â”‚ fileset()    â”‚â†’ â”‚ yamldecode() â”‚â†’ â”‚ for expr â”‚  â”‚    â”‚
â”‚  â”‚ â”‚ Load YAMLs   â”‚  â”‚ Parse        â”‚  â”‚ Transformâ”‚  â”‚    â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                            â”‚                                â”‚
â”‚                            â–¼                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ local.* maps                                       â”‚    â”‚
â”‚  â”‚ - applications_map                                 â”‚    â”‚
â”‚  â”‚ - human_identities_map                             â”‚    â”‚
â”‚  â”‚ - pki_auth_roles_map                               â”‚    â”‚
â”‚  â”‚ - human_with_github (filtered)                     â”‚    â”‚
â”‚  â”‚ - app_with_pki (filtered)                          â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                            â”‚                                â”‚
â”‚                            â–¼                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Resource Definitions (for_each)                    â”‚    â”‚
â”‚  â”‚ â”œâ”€ identities.tf                                   â”‚    â”‚
â”‚  â”‚ â”œâ”€ pki-auth.tf                                     â”‚    â”‚
â”‚  â”‚ â”œâ”€ applications.tf (+ module)                      â”‚    â”‚
â”‚  â”‚ â””â”€ ... (10+ files)                                 â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â”‚ Vault API calls
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  HashiCorp Vault                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Auth Backends                                        â”‚  â”‚
â”‚  â”‚ â”œâ”€ GitHub OAuth                                      â”‚  â”‚
â”‚  â”‚ â”œâ”€ GitHub Actions JWT                                â”‚  â”‚
â”‚  â”‚ â”œâ”€ Terraform Cloud JWT                               â”‚  â”‚
â”‚  â”‚ â”œâ”€ AWS IAM                                            â”‚  â”‚
â”‚  â”‚ â”œâ”€ Certificate (PKI)                                 â”‚  â”‚
â”‚  â”‚ â””â”€ AppRole                                            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Identity Layer                                       â”‚  â”‚
â”‚  â”‚                                                       â”‚  â”‚
â”‚  â”‚  Entities                    Entities                â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚  â”‚
â”‚  â”‚  â”‚ Humans     â”‚             â”‚ Apps       â”‚           â”‚  â”‚
â”‚  â”‚  â”‚ - Alice    â”‚             â”‚ - Backend  â”‚           â”‚  â”‚
â”‚  â”‚  â”‚ - Bob      â”‚             â”‚ - Frontend â”‚           â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚  â”‚
â”‚  â”‚     â”‚                           â”‚                     â”‚  â”‚
â”‚  â”‚     â”‚  Aliases                  â”‚  Aliases            â”‚  â”‚
â”‚  â”‚     â”œâ”€ github â†’ Alice           â”œâ”€ pki â†’ Backend     â”‚  â”‚
â”‚  â”‚     â””â”€ pki â†’ Alice              â”œâ”€ github â†’ Backend  â”‚  â”‚
â”‚  â”‚                                 â””â”€ aws â†’ Backend     â”‚  â”‚
â”‚  â”‚                                                       â”‚  â”‚
â”‚  â”‚  Groups                                               â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚  â”‚
â”‚  â”‚  â”‚ Platform Engineering       â”‚                      â”‚  â”‚
â”‚  â”‚  â”‚ - Members: Alice, Bob      â”‚                      â”‚  â”‚
â”‚  â”‚  â”‚ - Policies: platform-admin â”‚                      â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚  â”‚
â”‚  â”‚                                                       â”‚  â”‚
â”‚  â”‚  OIDC Provider                                        â”‚  â”‚
â”‚  â”‚  â”œâ”€ Human tokens (8h TTL)                            â”‚  â”‚
â”‚  â”‚  â””â”€ App tokens (30min TTL)                           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Secrets Engines                                      â”‚  â”‚
â”‚  â”‚ â”œâ”€ KV v2 (general + per-app)                         â”‚  â”‚
â”‚  â”‚ â”œâ”€ PKI (Root + Intermediate CA)                      â”‚  â”‚
â”‚  â”‚ â”œâ”€ Transit (Encryption-as-a-Service)                 â”‚  â”‚
â”‚  â”‚ â”œâ”€ AWS (Dynamic credentials)                         â”‚  â”‚
â”‚  â”‚ â””â”€ SSH (Certificate signing)                         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Policies (ACL)                                       â”‚  â”‚
â”‚  â”‚ â”œâ”€ super-user                                        â”‚  â”‚
â”‚  â”‚ â”œâ”€ application-identity-token-policies               â”‚  â”‚
â”‚  â”‚ â”œâ”€ human-identity-token-policies                     â”‚  â”‚
â”‚  â”‚ â”œâ”€ pki-self-renewal                                  â”‚  â”‚
â”‚  â”‚ â””â”€ app-specific (per env)                            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **Data Flow Diagram**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ YAML     â”‚
â”‚ File     â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ fileset()          â”‚  Discover all *.yaml
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ data.local_file    â”‚  Read file contents
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ yamldecode()       â”‚  Parse YAML â†’ HCL
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Group by type      â”‚  applications, identities, etc.
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Transform keys     â”‚  filename â†’ semantic field
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Filter by auth     â”‚  human_with_github, etc.
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ for_each resource  â”‚  Create Vault resources
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Vault API          â”‚  Apply configuration
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ Key Takeaways

### **The Brilliance of This Design:**

1. **Scalability:** Add 100 users = drop in 100 YAML files, one `terraform apply`
2. **Accessibility:** Non-Terraform users can edit YAML with schema validation
3. **Type Safety:** JSON Schema validates before Terraform runs
4. **Idempotency:** Terraform ensures desired state, no drift
5. **Version Control:** Full audit trail in Git, rollback capability
6. **Fail-Fast:** Validation catches errors at multiple stages
7. **Convention-Based:** Filename patterns drive behavior, less boilerplate
8. **Semantic Keys:** Resource addresses use meaningful names, not filenames
9. **Multi-Auth Support:** One identity, many login methods, seamless experience
10. **Zero-Trust Ready:** SPIFFE IDs for service mesh integration, cryptographic identity

### **The `for_each` Pattern Everywhere:**

This is the heart of the system:

```
YAML files
  â†“ for_each in data source
Load all files
  â†“ for expression in locals
Filter & transform
  â†“ for_each in resource
Create Vault resources
```

**Result:** Fully declarative, scalable, maintainable Vault configuration!

### **Why Two Separate Systems (Auth Role + Identity)?**

**Auth Roles** (pki-auth-roles/*.yaml):
- Answer: "Can you authenticate?"
- Grant initial policies
- Validate certificates

**Identity Entities** (identities/*.yaml):
- Answer: "Who are you?"
- Provide metadata & context
- Support multiple auth methods

**Together:**
- Auth role validates credentials
- Identity entity provides context
- Final token = merged policies + metadata

### **The Power of Convention:**

```
File: identities/human_alice.yaml
       â””â”€ "human_" prefix â†’ filtered into local.human_identities_map
       â””â”€ "application_" prefix â†’ filtered into local.application_identities_map

Field: config.identity.name = "Alice Smith"
       â””â”€ Becomes key in map â†’ vault_identity_entity.human["Alice Smith"]
       â””â”€ Stable across file renames

Field: config.authentication.github = "alice-gh"
       â””â”€ Non-empty â†’ added to local.human_with_github
       â””â”€ Creates vault_identity_entity_alias.github["Alice Smith"]
```

---

## ğŸ“š Further Reading

### **Related Files:**
- `CLAUDE.md` - Project-specific guidance for Claude Code
- `README.md` - Getting started guide
- `usecases/vault-as-identity-provider.md` - OIDC provider use case
- `identities/schema_human.yaml` - Human identity JSON Schema
- `identities/schema_application.yaml` - Application identity JSON Schema
- `.pre-commit-config.yaml` - Pre-commit hook configuration

### **Key Terraform Concepts:**
- `for_each` meta-argument
- `for` expressions
- `try()` function for error handling
- Data sources vs resources
- Module composition
- Lifecycle rules (`create_before_destroy`)

### **Vault Concepts:**
- Identity entities and aliases
- Authentication methods (GitHub, PKI, JWT, AWS IAM)
- Secrets engines (KV, PKI, Transit, AWS, SSH)
- Policies (ACL + Sentinel)
- OIDC provider configuration
- SPIFFE workload identity

---

## ğŸ Conclusion

This repository represents **enterprise-grade Vault configuration management** with:

âœ… Full version control via Git
âœ… Declarative YAML configuration
âœ… Multi-stage validation pipeline
âœ… Zero-trust cryptographic identity
âœ… Multi-modal authentication
âœ… Automated lifecycle management
âœ… Least-privilege access controls
âœ… Production-ready patterns

**The architecture enables teams to:**
- Manage Vault configuration as code
- Scale to hundreds or thousands of identities
- Maintain security best practices
- Audit all changes in Git history
- Collaborate across teams (YAML for config, Terraform for infrastructure)
- Integrate with modern CI/CD pipelines
- Support service mesh architectures (SPIFFE)

**This is Infrastructure as Code at its finest!** ğŸ‰

---

**Document Version:** 1.0
**Last Updated:** 2025-12-20
**Maintained By:** Infrastructure Team
